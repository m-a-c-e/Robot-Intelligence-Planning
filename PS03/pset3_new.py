class PSet3():

	def standard(self, n, test=False):
		if test:
			# only run code for passed in value of n
			# return time for specific n
			return 5
		else:
			# run function until completion
			# return a list of the time taken for each value of n
			# ex: return [1,2,3,5,10]
			return [1,2,3,5,10]

	def standard_return(self):
		# return list of values of n - please generate this on your computer and then hardcode the values here - they should match the plot
		return [1,2,3,5,10]


	def BT(self, n, test=False):
		if test:
			# only run code for passed in value of n
			# return time for specific n
			return 5
		else:
			# run function until completion
			# return a list of the time taken for each value of n
			# ex: return [1,2,3,5,10]
			return [1,2,3,5,10]

	def BT_return(self):
		# return list of values of n - please generate this on your computer and then hardcode the values here - they should match the plot
		return [1,2,3,5,10]


	def BT_w_FC(self, n, test=False):
		if test:
			# only run code for passed in value of n
			# return time for specific n
			return 5
		else:
			# run function until completion
			# return a list of the time taken for each value of n
			# ex: return [1,2,3,5,10]
			return [1,2,3,5,10]

	def BT_w_FC_return(self):
		# return list of values of n - please generate this on your computer and then hardcode the values here - they should match the plot
		return [1,2,3,5,10]


	def iterative_repair(self, n, test=False):
		if test:
			# only run code for passed in value of n
			# return time for specific n
			return 5
		else:
			# run function until completion
			# return a list of the time taken for each value of n
			# ex: return [1,2,3,5,10]
			return [1,2,3,5,10]

	def iterative_repair_return(self):
		# return list of values of n - please generate this on your computer and then hardcode the values here - they should match the plot
		return [1,2,3,5,10]

		


